<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.10"/>
<title>COS_Renesas: cos_linear_task_list.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">COS_Renesas
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.10 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">cos_linear_task_list.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Dies ist die renesas Version des 'co-operative' Schedulers.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &quot;<a class="el" href="cos__systime_8h_source.html">cos_systime.h</a>&quot;</code><br />
<code>#include &lt;stdlib.h&gt;</code><br />
</div>
<p><a href="cos__linear__task__list_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_cos_task__t.html">CosTask_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_node__t.html">Node_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ad7d34c47ed0b871745161775afc7e45a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cos__linear__task__list_8h.html#ad7d34c47ed0b871745161775afc7e45a">TASK_STATE_READY</a>&#160;&#160;&#160;0</td></tr>
<tr class="separator:ad7d34c47ed0b871745161775afc7e45a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82046bbe588f4534a2741f5c2ff951a8"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cos__linear__task__list_8h.html#a82046bbe588f4534a2741f5c2ff951a8">TASK_STATE_SUSPENDED</a>&#160;&#160;&#160;1</td></tr>
<tr class="separator:a82046bbe588f4534a2741f5c2ff951a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a615b8a1e56ec0a612fd589cda743f6b3"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cos__linear__task__list_8h.html#a615b8a1e56ec0a612fd589cda743f6b3">TASK_STATE_BLOCKED</a>&#160;&#160;&#160;2</td></tr>
<tr class="separator:a615b8a1e56ec0a612fd589cda743f6b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:aaaadcd8bd0c0f66476f5361e2f4f458a"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="struct_cos_task__t.html">CosTask_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cos__linear__task__list_8h.html#aaaadcd8bd0c0f66476f5361e2f4f458a">CosTask_t</a></td></tr>
<tr class="separator:aaaadcd8bd0c0f66476f5361e2f4f458a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b3dcee5f502d75f808228b368f59678"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="struct_node__t.html">Node_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cos__linear__task__list_8h.html#a8b3dcee5f502d75f808228b368f59678">Node_t</a></td></tr>
<tr class="separator:a8b3dcee5f502d75f808228b368f59678"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a6aa37ea8394635f8b70a69014b0d0816"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_node__t.html">Node_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cos__linear__task__list_8h.html#a6aa37ea8394635f8b70a69014b0d0816">_addTaskAtBeginningOfTaskList</a> (<a class="el" href="struct_node__t.html">Node_t</a> *root_pt, <a class="el" href="struct_cos_task__t.html">CosTask_t</a> *task_pt)</td></tr>
<tr class="separator:a6aa37ea8394635f8b70a69014b0d0816"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06545affd130024f7c4dfd20afa55bd9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_node__t.html">Node_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cos__linear__task__list_8h.html#a06545affd130024f7c4dfd20afa55bd9">_unlinkTaskFromTaskList</a> (<a class="el" href="struct_node__t.html">Node_t</a> *root_pt, <a class="el" href="struct_cos_task__t.html">CosTask_t</a> *task_pt)</td></tr>
<tr class="separator:a06545affd130024f7c4dfd20afa55bd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addce263bae5afdf53c8f7eb2dd3eb058"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_node__t.html">Node_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cos__linear__task__list_8h.html#addce263bae5afdf53c8f7eb2dd3eb058">_searchTaskInList</a> (<a class="el" href="struct_node__t.html">Node_t</a> *root_pt, <a class="el" href="struct_cos_task__t.html">CosTask_t</a> *task_pt)</td></tr>
<tr class="separator:addce263bae5afdf53c8f7eb2dd3eb058"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af70bc183da6678ece3c5b53c2d9bad7b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_node__t.html">Node_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cos__linear__task__list_8h.html#af70bc183da6678ece3c5b53c2d9bad7b">_searchPredecessorTaskInList</a> (<a class="el" href="struct_node__t.html">Node_t</a> *root_pt, <a class="el" href="struct_cos_task__t.html">CosTask_t</a> *task_pt)</td></tr>
<tr class="separator:af70bc183da6678ece3c5b53c2d9bad7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a690c9246b79f10af9cd20ba56e35a1b4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_node__t.html">Node_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cos__linear__task__list_8h.html#a690c9246b79f10af9cd20ba56e35a1b4">_newNode</a> (<a class="el" href="struct_cos_task__t.html">CosTask_t</a> *task_pt)</td></tr>
<tr class="separator:a690c9246b79f10af9cd20ba56e35a1b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e90abce91f5d09641a0d5b6d522e507"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cos__linear__task__list_8h.html#a7e90abce91f5d09641a0d5b6d522e507">_sortLinearListPrio</a> (<a class="el" href="struct_node__t.html">Node_t</a> *root_pt)</td></tr>
<tr class="separator:a7e90abce91f5d09641a0d5b6d522e507"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a825afe18babf0ce0d49c542a2b238e6e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_cos_task__t.html">CosTask_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cos__linear__task__list_8h.html#a825afe18babf0ce0d49c542a2b238e6e">_newTask</a> (<a class="el" href="cos__types_8h.html#ab077fa1127453be2bd9d4c3c8a768fa7">uint8_t</a> prio, void *pData, void(*func)(<a class="el" href="struct_cos_task__t.html">CosTask_t</a> *))</td></tr>
<tr class="separator:a825afe18babf0ce0d49c542a2b238e6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Dies ist die renesas Version des 'co-operative' Schedulers. </p>
<dl class="section user"><dt>Project : co-operative scheduler renesas uC</dt><dd></dd></dl>
<dl class="section user"><dt>Module : linear task list implementation</dt><dd></dd></dl>
<dl class="section user"><dt>Author : Fgb</dt><dd></dd></dl>
<dl class="section user"><dt>Department: E14</dt><dd></dd></dl>
<dl class="section user"><dt>Company : Fachhochschule Hannover - University of Applied</dt><dd>Sciences and Arts</dd></dl>
<dl class="section user"><dt>History :</dt><dd><pre class="fragment">   Version | Date        | Author        | Change Description
   0.0     | 21.03. 2011 | Fgb           | First Version, Linux
   0.1     | 17.09. 2013 | Fgb           | nur noch Atmel, deutsche Doku.
   0.2     | 09.10.2015  | Fgb           | umgestiegen auf renesas controller</pre></dd></dl>
<p>Routinen zur Verwaltung einer linearen Task-Liste:</p>
<pre class="fragment">                          node
           root          --------      --------           --------
           -----         |      |-----&gt;|      |-- ... ---&gt;|      |----&gt; NULL
           |   |--------&gt;|......|      |......|           |......|
           -----         |      |      |      |           |      |
                         --------      --------           --------
                            |             |                  |
                            \/            \/                 \/
                          -----         -----              -----
                          |   |         |   |              |   |
                          -----         -----              -----
                          task</pre> 
<p>Definition in file <a class="el" href="cos__linear__task__list_8h_source.html">cos_linear_task_list.h</a>.</p>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a class="anchor" id="a615b8a1e56ec0a612fd589cda743f6b3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define TASK_STATE_BLOCKED&#160;&#160;&#160;2</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="cos__linear__task__list_8h_source.html#l00077">77</a> of file <a class="el" href="cos__linear__task__list_8h_source.html">cos_linear_task_list.h</a>.</p>

</div>
</div>
<a class="anchor" id="ad7d34c47ed0b871745161775afc7e45a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define TASK_STATE_READY&#160;&#160;&#160;0</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="cos__linear__task__list_8h_source.html#l00075">75</a> of file <a class="el" href="cos__linear__task__list_8h_source.html">cos_linear_task_list.h</a>.</p>

</div>
</div>
<a class="anchor" id="a82046bbe588f4534a2741f5c2ff951a8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define TASK_STATE_SUSPENDED&#160;&#160;&#160;1</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="cos__linear__task__list_8h_source.html#l00076">76</a> of file <a class="el" href="cos__linear__task__list_8h_source.html">cos_linear_task_list.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="aaaadcd8bd0c0f66476f5361e2f4f458a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="struct_cos_task__t.html">CosTask_t</a> <a class="el" href="struct_cos_task__t.html">CosTask_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section user"><dt>Beschreibung</dt><dd>Task-Sturktur des 'co-operative' Schedulers. Der Scheduler startet die Funktion 'func', aktualisiert 'lastActivationTime_Ticks' auf die aktuelle Zeit in 'Ticks' und setzt 'nextActivationTime_Ticks = lastActivationTime_Ticks'. Dadurch wird der Scheduler veranlasst, die Task so schnell wie moeglich wieder zu starten, ohne weitere 'sleep' Zeit. Falls die Task erst nach einer definierten 'sleep' Zeit erneut laufen soll, muss sie das 'sleep'-Macro explizit aufrufen. Dadurch wird die neue Startzeit gesetzt auf: 'nextActivationTime_Ticks = lastActivationTime_Ticks + sleepTime_Ticks'.</dd></dl>
<dl class="section user"><dt>Task Zustaende</dt><dd>Eine Task kann im Zustand 'ready' sein, man kann sie mit einem speziellen Kommando in den Zustand 'suspended' versetzen oder mit einem Semphor in den Zustand 'blocked' bringen.</dd></dl>
<dl class="section user"><dt>Re-entry Punkt</dt><dd>Der 'co-operative' Scheduler startet die Task-Funktio, die ihre Arbeit in der Programmzeile 'lineCnt' wieder aufnimmt. Das Anspringen dieser Programmzeile wird mit Hilfe von Macros erreicht.</dd></dl>
<dl class="section user"><dt>User data: private Daten der Task</dt><dd>Eine Task kann lokale Daten in 'static' Variablen speichern, die ihre Werte bis zum naechsten Funktionsaufruf behalten. Dies ist einfach, aber die Task-Funktion kann dann nur in einer einzigen Instanz laufen, denn static Variable sind der Funktion zugeordnet, nicht der Task-Struktur. Wenn man mehrere Tasks erzeugen will, die alle dieselbe Task-Funktion 'func' in mehreren Instanzen nutzen, muss man die lokalen Daten der Task-Stuktur zuordnen, nicht dem Funktionscode. Der Zeiger 'pData' kann benutzt werden, um auf Nutzerdaten der Task zu zeigen. Diese Daten sind dann privat fuer jede Task (Instanz).</dd></dl>
<dl class="section see"><dt>See also</dt><dd></dd></dl>

<p>Definition at line <a class="el" href="cos__linear__task__list_8h_source.html#l00118">118</a> of file <a class="el" href="cos__linear__task__list_8h_source.html">cos_linear_task_list.h</a>.</p>

</div>
</div>
<a class="anchor" id="a8b3dcee5f502d75f808228b368f59678"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="struct_node__t.html">Node_t</a> <a class="el" href="struct_node__t.html">Node_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="cos__linear__task__list_8h_source.html#l00135">135</a> of file <a class="el" href="cos__linear__task__list_8h_source.html">cos_linear_task_list.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a6aa37ea8394635f8b70a69014b0d0816"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_node__t.html">Node_t</a>* _addTaskAtBeginningOfTaskList </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_node__t.html">Node_t</a> *&#160;</td>
          <td class="paramname"><em>root_pt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_cos_task__t.html">CosTask_t</a> *&#160;</td>
          <td class="paramname"><em>task_pt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section user"><dt>Beschreibung</dt><dd>Erzeugt einen neuen Lisenknoten, verbindet die Task mit diesem Knoten und fuegt den Konten als erstes Element in die Liste ein. D.h. der root-Zeiger der Liste aendert sich! Der neue root-Zeiger wird mit return zurueckgegeben. Die Task-Struktur, auf die task-Pt zeigt, muss vor dem Aufruf dieser Funktion initialisiert sein.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cos__linear__task__list_8c.html#a06545affd130024f7c4dfd20afa55bd9">_unlinkTaskFromTaskList()</a>, <a class="el" href="cos__linear__task__list_8c.html#a690c9246b79f10af9cd20ba56e35a1b4">_newNode()</a> <ul>
<li></li>
</ul>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">root_pt</td><td>- IN, Zeiger auf das erste Listenelement </td></tr>
    <tr><td class="paramname">task_pt</td><td>- IN, Zeiger auf initialisierte Task-Struktur</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">neuer</td><td>Zeiger auf das erste Listenelement</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Code-Beispiel::</dt><dd><pre class="fragment">int main(void)
{   Node_t *root_pt=NULL;
    CosTask_t *pt=NULL;

    ...
    pt = _newTask(...);
    root_pt = _addTaskAtBeginningOfTaskList(root_pt, pt);
    ...

    return 0;
}
</pre> </dd></dl>

<p>Definition at line <a class="el" href="cos__linear__task__list_8c_source.html#l00127">127</a> of file <a class="el" href="cos__linear__task__list_8c_source.html">cos_linear_task_list.c</a>.</p>

</div>
</div>
<a class="anchor" id="a690c9246b79f10af9cd20ba56e35a1b4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_node__t.html">Node_t</a>* _newNode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_cos_task__t.html">CosTask_t</a> *&#160;</td>
          <td class="paramname"><em>task_pt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section user"><dt>Beschreibung</dt><dd>Gegeben ist der Zeiger auf eine Task. Diese Funktion erzeugt einen neuen Knoten und verbindet ihn mit der Task. Der Zeiger auf den neuen Knoten wird zurueck gegeben.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cos__linear__task__list_8c.html#a6aa37ea8394635f8b70a69014b0d0816">_addTaskAtBeginningOfTaskList()</a> <ul>
<li></li>
</ul>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">task_pt</td><td>- IN, Zeiger auf initialisierte Task-Struktur</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">Zeiger</td><td>auf den neuen Knoten</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Code-Beispiel::</dt><dd><pre class="fragment">int main(void)
{   Node_t *npt=NULL;
    CosTask_t *pt=NULL;

    ...
    pt  = _newTask(...);
    npt = _newNode(pt);
    ...

    return 0;
}
</pre> </dd></dl>

<p>Definition at line <a class="el" href="cos__linear__task__list_8c_source.html#l00341">341</a> of file <a class="el" href="cos__linear__task__list_8c_source.html">cos_linear_task_list.c</a>.</p>

</div>
</div>
<a class="anchor" id="a825afe18babf0ce0d49c542a2b238e6e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_cos_task__t.html">CosTask_t</a>* _newTask </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="cos__types_8h.html#ab077fa1127453be2bd9d4c3c8a768fa7">uint8_t</a>&#160;</td>
          <td class="paramname"><em>prio</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(<a class="el" href="struct_cos_task__t.html">CosTask_t</a> *)&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section user"><dt>Beschreibung</dt><dd>Alloziert Speicher fuer eine Task-Struktur und initialisiert ihn. Der Zeiger auf die Struktur wird zurueck gegeben.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cos__linear__task__list_8c.html#a6aa37ea8394635f8b70a69014b0d0816">_addTaskAtBeginningOfTaskList()</a>, <a class="el" href="cos__linear__task__list_8c.html#a690c9246b79f10af9cd20ba56e35a1b4">_newNode()</a> <ul>
<li></li>
</ul>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">prio</td><td>- IN Prioritaet der Task (min) 1..254 (max) </td></tr>
    <tr><td class="paramname">pData</td><td>-IN Zeiger auf private Nutzerdaten der Task </td></tr>
    <tr><td class="paramname">func</td><td>-IN Name der Task-Funktion</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">Zeiger</td><td>auf die neue Task-Struktur oder NULL bei Fehler</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Code-Beispiel::</dt><dd><pre class="fragment">int main(void)
{   Node_t *npt=NULL;
    CosTask_t *pt=NULL;

    ...
    pt  = _newTask(...);
    npt = _newNode(pt);
    ...

    return 0;
}
</pre> </dd></dl>

<p>Definition at line <a class="el" href="cos__linear__task__list_8c_source.html#l00383">383</a> of file <a class="el" href="cos__linear__task__list_8c_source.html">cos_linear_task_list.c</a>.</p>

</div>
</div>
<a class="anchor" id="af70bc183da6678ece3c5b53c2d9bad7b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_node__t.html">Node_t</a>* _searchPredecessorTaskInList </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_node__t.html">Node_t</a> *&#160;</td>
          <td class="paramname"><em>root_pt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_cos_task__t.html">CosTask_t</a> *&#160;</td>
          <td class="paramname"><em>task_pt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section user"><dt>Beschreibung</dt><dd>Gegeben ist der Zeiger auf eine Task. Diese Funktion durchsucht die Liste nach dem Vorgaengerknoten der Task. Die Funktion gibt den Zeiger auf den Vorgaengerknoten zurueck, oder NULL, falls nichts gefunden wurde.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cos__linear__task__list_8c.html#addce263bae5afdf53c8f7eb2dd3eb058">_searchTaskInList()</a>, <a class="el" href="cos__linear__task__list_8c.html#a06545affd130024f7c4dfd20afa55bd9">_unlinkTaskFromTaskList()</a> <ul>
<li></li>
</ul>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">root_pt</td><td>- IN, Zeiger auf das erste Listenelement </td></tr>
    <tr><td class="paramname">task_pt</td><td>- IN, Zeiger auf initialisierte Task-Struktur</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">Zeiger</td><td>auf den Vorgaengerknoten der Task</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Code-Beispiel::</dt><dd><pre class="fragment">int main(void)
{   Node_t *root_pt=NULL;
    Node_t *npt=NULL;
    CosTask_t *pt=NULL;

    ...
    pt = _newTask(...);
    root_pt = _addTaskAtBeginningOfTaskList(root_pt, pt);
    ...
    npt = _searchPredecessorTaskInList(root_pt, pt);
    ...

    return 0;
}
</pre> </dd></dl>

<p>Definition at line <a class="el" href="cos__linear__task__list_8c_source.html#l00287">287</a> of file <a class="el" href="cos__linear__task__list_8c_source.html">cos_linear_task_list.c</a>.</p>

</div>
</div>
<a class="anchor" id="addce263bae5afdf53c8f7eb2dd3eb058"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_node__t.html">Node_t</a>* _searchTaskInList </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_node__t.html">Node_t</a> *&#160;</td>
          <td class="paramname"><em>root_pt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_cos_task__t.html">CosTask_t</a> *&#160;</td>
          <td class="paramname"><em>task_pt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section user"><dt>Beschreibung</dt><dd>Gegeben ist der Zeiger auf eine Task. Diese Funktion durchsucht die lineare Liste nach dem Knoten, der mit der Task verbunden ist. Die Funktion gibt einen Zeiger auf diesen Knoten zurueck, oder NULL, falls nichts gefunden wurde.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cos__linear__task__list_8c.html#a06545affd130024f7c4dfd20afa55bd9">_unlinkTaskFromTaskList()</a> <ul>
<li></li>
</ul>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">root_pt</td><td>- IN, Zeiger auf das erste Listenelement </td></tr>
    <tr><td class="paramname">task_pt</td><td>- IN, Zeiger auf initialisierte Task-Struktur</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">Zeiger</td><td>auf den Konten, der mit Task *task_pt verbunden ist</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Code-Beispiel::</dt><dd><pre class="fragment">int main(void)
{   Node_t *root_pt=NULL;
    Node_t *npt=NULL;
    CosTask_t *pt=NULL;

    ...
    pt = _newTask(...);
    root_pt = _addTaskAtBeginningOfTaskList(root_pt, pt);
    ...
    npt = _searchTaskInList(root_pt, pt);
    ...

    return 0;
}
</pre> </dd></dl>

<p>Definition at line <a class="el" href="cos__linear__task__list_8c_source.html#l00239">239</a> of file <a class="el" href="cos__linear__task__list_8c_source.html">cos_linear_task_list.c</a>.</p>

</div>
</div>
<a class="anchor" id="a7e90abce91f5d09641a0d5b6d522e507"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void _sortLinearListPrio </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_node__t.html">Node_t</a> *&#160;</td>
          <td class="paramname"><em>root_pt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section user"><dt>Beschreibung</dt><dd>Sortiert die lineare Liste nach Task Prioritaet. Die Task mit der hoechsten Prioritaet steht vorne in der Liste. Der root-Zeiger der Liste bleibt unveraendert, da hier nur die 'Nutzlast' der Knoten getauscht wird, und nicht die Knotenreihenfolge geaendert wird.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><ul>
<li></li>
</ul>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">root_pt</td><td>- IN, Zeiger auf das erste Listenelement</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">none</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Code-Beispiel::</dt><dd><pre class="fragment">int main(void)
{   ...
    _sortLinearListPrio(root_pt);
    ...

    return 0;
}
</pre> </dd></dl>

<p>Definition at line <a class="el" href="cos__linear__task__list_8c_source.html#l00428">428</a> of file <a class="el" href="cos__linear__task__list_8c_source.html">cos_linear_task_list.c</a>.</p>

</div>
</div>
<a class="anchor" id="a06545affd130024f7c4dfd20afa55bd9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_node__t.html">Node_t</a>* _unlinkTaskFromTaskList </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_node__t.html">Node_t</a> *&#160;</td>
          <td class="paramname"><em>root_pt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_cos_task__t.html">CosTask_t</a> *&#160;</td>
          <td class="paramname"><em>task_pt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section user"><dt>Beschreibung</dt><dd>Diese Routine durchsucht die Task-Liste nach dem Knoten, der auf dieselbe Task zeigt, wie task_pt. Der Knoten wird aus der Liste geloescht, und sein Speicher wird freigegeben. Die Task-Struktur wird aber nicht geloescht, da sie noch Teil einer anderen Liste sein koennte. (Bsp: Auch Semaphoren besitzen eine lineare Liste der an ihnen wartenden Tasks) Der root-Zeiger der Liste wird geaendert, falls der erste Konten der Liste geloescht wurde. Die Funktion gibt den (ggf.) neuen root-Zeiger mit return zurueck.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cos__linear__task__list_8c.html#a6aa37ea8394635f8b70a69014b0d0816">_addTaskAtBeginningOfTaskList()</a>, <a class="el" href="cos__linear__task__list_8c.html#a690c9246b79f10af9cd20ba56e35a1b4">_newNode()</a> <ul>
<li></li>
</ul>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">root_pt</td><td>- IN, Zeiger auf das erste Listenelement </td></tr>
    <tr><td class="paramname">task_pt</td><td>- IN, Zeiger auf initialisierte Task-Struktur</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">neuer</td><td>Zeiger auf das erste Listenelement</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Code-Beispiel::</dt><dd><pre class="fragment">int main(void)
{   Node_t *root_pt=NULL;
    CosTask_t *pt=NULL;

    ...
    pt = _newTask(...);
    root_pt = _addTaskAtBeginningOfTaskList(root_pt, pt);
    ...
    root_pt = _unlinkTaskFromTaskList(root_pt, pt);
    ...


    return 0;
}
</pre> </dd></dl>

<p>Definition at line <a class="el" href="cos__linear__task__list_8c_source.html#l00175">175</a> of file <a class="el" href="cos__linear__task__list_8c_source.html">cos_linear_task_list.c</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.10
</small></address>
</body>
</html>
